//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//             _    _                             _      _  _               //
//        ___ | |_ | |__    ___  _ __  _ __ ___  (_)  __| |(_)    ___       //
//       / _ \| __|| '_ \  / _ \| '__|| '_ ` _ \ | | / _` || |   / __|      //
//      |  __/| |_ | | | ||  __/| |   | | | | | || || (_| || | _| (__       //
//       \___| \__||_| |_| \___||_|   |_| |_| |_||_| \__,_||_|(_)\___|      //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//          Copyright (c) 2018 by S.F.T. Inc. - All rights reserved         //
//  Use, copying, and distribution of this software are licensed according  //
//    to the GPLv2, LGPLv2, or BSD license, as appropriate (see COPYING)    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

// This program uses libfluidsynth to generate MIDI output based on UDP packets
// received on a listening interface (default 0.0.0.0 on port 9000).
//
// The MIDI packets are in a format as generated by the 'EthernetMIDI' application,
// written by Benno Senoner - http://linuxsampler.org/ethernetmidi/
//
// The intent is to allow a Linux or BSD computer to act as a soundfont synth
// without additional MIDI cables, from a windows computer using an application
// like 'Cakewalk' that requires Windows.
//
// To make this work, you have to be able to run the 'EthernetMIDI' application
// on the windows computer, using a 'midi loopback' device (similar to LoopBE;
// for more information on LoopBE see http://www.nerds.de/en/loopbe30.html )
//
// Other windows midi loopback driver software also exists.
//
// Additional links: http://www.copperlan.org/index.php/download
//                   https://www.tobias-erichsen.de/software/loopmidi.html
//                   http://www.midiox.com/myoke.htm
//
// Then, the MIDI application (let's say cakewalk) will be configured to use
// the MIDI loopback device, which will then cause 'EthernetMIDI' to send UDP
// packets to a Linux or FreeBSD machine running this program.  Then, the
// 'EtherMIDI' application (this one) invokes fluidsynth to play the MIDI content.


// Alternately, this program sets up an instance of 'fluidsynth', either listening
// on a character device that was created by 'cuse4bsd', or a FIFO, for incoming
// MIDI traffic via UDP on a specified port.  See pre-defined constants, below


#define USE_LIBFLUIDSYNTH          /* do the deed using libfluidsynth - best method */
//#define USE_CUSE                 /* use CUSE to create a device driver for fluidsynth to listen on in lieu of a FIFO */
//#define USE_LIBFLUIDSYNTH_PARSER /* use the undocumented 'parser' for libfluidsynth */

#define DEFAULT_FREEBSD_OUT_DEVICE "oss"
#define DEFAULT_LINUX_OUT_DEVICE "pulseaudio"


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdarg.h>
#include <unistd.h>
#include <string.h>
#include <memory.h>
#include <signal.h>
#include <limits.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/soundcard.h> // use this to get soundcard IOCTL definitions


// need to include 'cuse4bsd' header - compile with -lcuse4bsd -lthr  and  -I /usr/local/include -L /usr/local/lib

#ifdef USE_CUSE
#ifndef __FreeBSD__
#error this only works for FreeBSD
#endif // __FreeBSD__
#include <cuse4bsd.h> // in /usr/local/include
#endif // USE_CUSE

#ifdef USE_LIBFLUIDSYNTH
#include <fluidsynth.h>

#ifdef USE_LIBFLUIDSYNTH_PARSER
#ifndef _FLUID_MIDI_H /* these definitions are actually in a private file that builds the lib */

// TODO:  this only works if /usr/local/lib/libfluidsynth.so has the exports for these 3 functions
//        maybe have autoconf use objdump -T and look for them?

struct _fluid_midi_parser_t
{
  void *pDummy;
};
typedef struct _fluid_midi_parser_t fluid_midi_parser_t;

fluid_midi_parser_t* new_fluid_midi_parser(void);
int delete_fluid_midi_parser(fluid_midi_parser_t* parser);
fluid_midi_event_t* fluid_midi_parser_parse(fluid_midi_parser_t* parser, unsigned char c);

#endif // _FLUID_MIDI_H

#else // USE_LIBFLUIDSYNTH_PARSER
void do_midi_command(unsigned int nBytes, unsigned char *pData, fluid_synth_t *pS);
#endif // USE_LIBFLUIDSYNTH_PARSER

#endif // USE_LIBFLUIDSYNTH



void hup_handler(int iSig); // call 'signal(SIGHUP, hup_handler)' to enable it
// also might handle SIGQUIT, SIGKILL, SIGTERM

int do_main(int iListen, const char *szSoundFont);

unsigned int MyGetTickCount();
void MySleep(unsigned int dwMsec);
int TimeIntervalExceeds(unsigned int dwStart, unsigned int dwMSec);


typedef struct __my_buf__
{
  int cbBuf;
  int nHead, nTail;
  unsigned char buffer[4];
} MY_BUF;

#define MY_BUF_SIZE 65536

typedef void *(the_thread_proc)(void *pArg);
pthread_t MyCreateThread(the_thread_proc *pProc, void *pParam);

int my_buf_len(const MY_BUF *pBuf);
int my_buf_remaining(const MY_BUF *pBuf);
void my_buf_write(MY_BUF *pBuf, const char *pData, int cbLen);
int my_buf_read(MY_BUF *pBuf, char *pData, int cbLen);


// these borrowed from X11workbench, 'platform_helper.c'

#define WB_INVALID_FILE_HANDLE -1
#define WB_PROCESS_ID pid_t
#define WB_FILE_HANDLE int

WB_PROCESS_ID WBRunAsync(const char *szAppName, ...);


void usage(void)
{
  fputs("Usage:  ethermidi [-d][-Fwavetable.sf2][-o output] [[ip][:port]]\n"
        "where   '-F' specifies a wavetable that immediately follows '-F'\n"
        " and    '-d' runs the application as a daemon\n"
        " and    '-o' specifies the output device [default is "
#ifdef __FreeBSD__
        DEFAULT_FREEBSD_OUT_DEVICE
#else // linux
        DEFAULT_LINUX_OUT_DEVICE
#endif // __FreeBSD__ or linux
        "]\n"
        " and    'ip:port specifies an optional ip address and/or port to listen on\n"
        "        the default port is 9000; specifying blank IP listens on all.\n"
        "        NOTE:  IPv6 addresses should be expressed as '[ip:ad:dr:es:s]:port'\n",
        stderr);
}

// NOTE:  Ethernet MIDI driver on windows generates UDP packets (default port 9000) with the following format:
//
// low endian long integer:  00000000H  byte sequence 00,00,00,00  [unknown purpose, always 0]
// low endian long integer:  00000003H  byte sequence 03,00,00,00  [length of MIDI data?]
// 3 bytes of data (MIDI sequence)


char szWaveTable[PATH_MAX * 2 + 2] = "";
char szOutDev[PATH_MAX * 2 + 2] = "";

int DoListenSocket(const char *szIPPort)
{
struct sockaddr_storage sa; // sufficiently large enough to handle IPv4 or IPv6
struct sockaddr_in *pSA4 = NULL;
struct sockaddr_in6 *pSA6 = NULL;
int iRval;
short sPort;
const char *pTemp, *pIPPort;
char *pTemp2;


  memset(&sa, 0, sizeof(sa));

  pIPPort = szIPPort;
  pTemp = NULL; // initially, make sure

  if(*pIPPort == '[') // required for ipv6 as "[ip:ad:dre:ss]:port"
  {
    pSA6 = (struct sockaddr_in6 *)&sa;
    pSA6->sin6_family = AF_INET6;
#ifdef __FreeBSD__ /* Linux doesn't have this data member */
    pSA6->sin6_len = sizeof(*pSA6);
#endif // __FreeBSD__

    pTemp = strchr(pIPPort, ']');

    // zero-byte the ']' at the end by copying to a buffer, first
    if(pTemp && (!pTemp[1] || pTemp[1] == ':')) // should be
    {
      pTemp2 = malloc((pTemp - pIPPort) + 2);
      if(!pTemp2)
      {
        fprintf(stderr, "Not enough memory to evaluate IPv6 address - errno=%d\n", errno);
        return -1;
      }

      memcpy(pTemp2, pIPPort + 1, (pTemp - pIPPort) - 1);
      pTemp2[pTemp - pIPPort - 1] = 0;

      pTemp++; // points to end of string or ':' now
    }
    else
    {
      fprintf(stderr, "Invalid ipv6 '%s'\n (must be '[IPv6]' or '[IPv6]:port')\n", pIPPort);
      return -1;
    }

    // passing sin6_addr was determined by experimentation, hopefully consistent across platforms
    if(0 >= inet_pton(AF_INET6, pTemp2, &(pSA6->sin6_addr)))
    {
      fprintf(stderr, "Invalid ipv6 '[%s]%s'\n (must be '[IPv6]:port' or '[IPv6]')\n", pTemp2, pTemp);

      free(pTemp2);
      usage();
      return -1;
    }

    pIPPort = pTemp; // point to the ':' (or end of string)

    free(pTemp2);
  }
  else if(*pIPPort)
  {
    pSA4 = (struct sockaddr_in *)&sa;
    pSA4->sin_family = AF_INET;
#ifdef __FreeBSD__ /* Linux doesn't have this data member */
    pSA4->sin_len = sizeof(*pSA4);
#endif // __FreeBSD__


    // assume ipv4 address for now, ':' is port separator
    pTemp = strrchr(pIPPort, ':'); // reverse look for ':'
    if(!pTemp)
    {
      pTemp = pIPPort + strlen(pIPPort);
    }

    if((pTemp - pIPPort) == 9 && !strncmp(pIPPort, "localhost", 9))
    {
      uint32_t ulTemp = htonl(INADDR_LOOPBACK); // localhost, 127.0.0.1

      // this assigns 'sin_addr' assuming it's a uint32_t
      *((uint32_t *)&(pSA4->sin_addr)) = ulTemp;
    }
    else if(pTemp > pIPPort)
    {
      pTemp2 = malloc((pTemp - pIPPort) + 2);
      if(!pTemp2)
      {
        fprintf(stderr, "Not enough memory to evaluate IPv6 address - errno=%d\n", errno);
        return -1;
      }

      memcpy(pTemp2, pIPPort, pTemp - pIPPort);
      pTemp2[pTemp - pIPPort] = 0;

      if(0 >= inet_pton(AF_INET, pTemp2, &(pSA4->sin_addr)))
      {
        fprintf(stderr, "Invalid ip '%s'\n (must be '[IPv6]' '[IPv6]:port' 'IP' 'IP:port' or ':port')\n", pIPPort);

        free(pTemp2);
        usage();
        return -1;
      }

      free(pTemp2);
    }

    // TODO:  if IPv6 not supported, use the old method   *((uint32_t *)&(pSA4->sin_addr)) = 0;

    else // bind to '0' using IPv6 - this way it's a 'udp46' socket, accepting either protocol
    {
//      *((uint32_t *)&(pSA4->sin_addr)) = 0;

      pSA4 = NULL;
      pSA6 = (struct sockaddr_in6 *)&sa;
      pSA6->sin6_family = AF_INET6;
#ifdef __FreeBSD__ /* Linux doesn't have this data member */
      pSA6->sin6_len = sizeof(*pSA6);
#endif // __FreeBSD__
    }
  }

  if(pTemp && pTemp[1])
  {
    sPort = atoi(pTemp + 1);
  }
  else
  {
    sPort = 9000; // default
  }

  if(pSA6)
  {
    pSA6->sin6_port = htons(sPort);
  }
  else
  {
    pSA4->sin_port = htons(sPort);
  }
//    if(pSA6 || pSA4)
//    {
//      char tbuf[256];
//
//      fprintf(stderr, "TEMPORARY:  inet_ntop() returns \"%s\"\n",
//              inet_ntop(pSA6 ? AF_INET6 : AF_INET,
//                        (struct in_addr *)(pSA6 ? (void *)&(pSA6->sin6_addr) : (void *)&(pSA4->sin_addr)),
//                        tbuf, sizeof(tbuf)));
//    }

  iRval = socket((pSA6 ? PF_INET6 : PF_INET), SOCK_DGRAM, IPPROTO_UDP);

  if(iRval != -1)
  {
    int i2;

    if(pSA6)
    {
      i2 = bind(iRval, (const struct sockaddr *)pSA6, sizeof(*pSA6));
    }
    else // pSA4
    {
      i2 = bind(iRval, (const struct sockaddr *)pSA4, sizeof(*pSA4));
    }

    if(i2 < 0)
    {
      char tbuf[256];

      fprintf(stderr, "Unable to bind socket for '%s', errno=%d\n", szIPPort, errno);
      close(iRval);

      fprintf(stderr, "  inet_ntop() returns \"%s\"\n",
              inet_ntop(pSA6 ? AF_INET6 : AF_INET,
                        pSA6 ? (struct in_addr *)&(pSA6->sin6_addr) : &(pSA4->sin_addr),
                        tbuf, sizeof(tbuf)));

      iRval = -1;
    }
  }
  else
  {
    fprintf(stderr, "Unable to create socket for '%s', errno=%d\n", szIPPort, errno);
    return -1;
  }

  return iRval;
}



// invoke fluidsynth with these parameters
// fluidsynth -m [alsa_seq? coremidi?] -p /dev/[cuse-device-name] [soundfontfile]
// possibly use ' -m oss -o "midi.oss.device /dev/[cuse-device-name]" '

int main(int argc, char *argv[])
{
int i1, iSocket = -1;
int bDaemon = 0;  // boolean flags, actually


  while((i1 = getopt(argc, argv, "hdF:o:" )) != -1)
  {
    switch(i1)
    {
      case 'h':
        usage();
        return 0;

      case 'd':
        bDaemon = 1;
        break;

      case 'F':
        strncpy(szWaveTable, optarg, sizeof(szWaveTable));
        break;

      case 'o':
        strncpy(szOutDev, optarg, sizeof(szOutDev));
        break;

      default:
        usage();
        return 1;
    }
  }

  argc -= optind;
  argv += optind;

  if(bDaemon)
  {
    i1 = fork();
    if(i1 < 0)
    {
      fprintf(stderr, "Unable to fork to daemon process, errno=%d\n", errno);
      return 2;
    }

    if(i1 > 0)
    {
      fprintf(stderr, "Daemonizing as process %d (%xH)\n", i1, i1);
      return 0;
    }

    close(0); // close stdin - I don't want it - but keep stdout just in case...

    // TODO:  do I re-direct stderr and stdout to something that logs it?
  }

  if(argc < 1) // remaining args [argv[0] already stripped away]
  {
    iSocket = DoListenSocket(":9000"); // assume 'bind to all' with default port
  }
  else
  {
    // TODO:  do I want to listen to multiple sockets?

    iSocket = DoListenSocket(argv[0]);
  }

  if(iSocket == -1)
  {
    fprintf(stderr, "ERROR: %d while creating socket\n", errno);
    return 1;
  }


  do_main(iSocket, szWaveTable);

  close(iSocket);

  return 0;
}

// thread utilities

pthread_t MyCreateThread(the_thread_proc *pProc, void *pParam)
{
pthread_t thr;

  if(!pthread_create(&thr, NULL, pProc, pParam))
  {
    return thr;
  }

  return 0; // return -1 instead?
}


#ifdef USE_CUSE

int my_cm_open(struct cuse_dev *, int fflags);
int my_cm_close(struct cuse_dev *, int fflags);
int my_cm_read(struct cuse_dev *, int fflags, void *user_ptr, int len);
int my_cm_write(struct cuse_dev *, int fflags, const void *user_ptr, int len);
int my_cm_ioctl(struct cuse_dev *, int fflags, unsigned long cmd, void *user_data);
int my_cm_poll(struct cuse_dev *, int fflags, int events);


static struct cuse_methods sCM =
{
  .cm_open = my_cm_open,
  .cm_close = my_cm_close,
  .cm_read = my_cm_read,
  .cm_write = my_cm_write,
  .cm_ioctl = my_cm_ioctl,
  .cm_poll = my_cm_poll
};

#endif // USE_CUSE


int my_buf_len(const MY_BUF *pBuf)
{
  if(pBuf->nHead < pBuf->nTail)
  {
    return (pBuf->nHead + pBuf->cbBuf) - pBuf->nTail;
  }

  return pBuf->nHead - pBuf->nTail;
}

int my_buf_remaining(const MY_BUF *pBuf)
{
int iLen = my_buf_len(pBuf);

  return pBuf->cbBuf - 1 - iLen;
}

void my_buf_write(MY_BUF *pBuf, const char *pData, int cbLen)
{
int iTemp;

//  fprintf(stderr, "TEMP2 enter %d %d %d - %d\n", cbLen, pBuf->nHead, pBuf->nTail, my_buf_remaining(pBuf));  // TEMPORARY

  // assumes 'cbLen' less than 'my_buf_remaining()' return value
  // otherwise the head/tail pointers may crash

  iTemp = pBuf->nHead + cbLen;
  if(iTemp > pBuf->cbBuf)
  {
    iTemp = pBuf->cbBuf - pBuf->nHead;  // # of bytes to the end
  }
  else
  {
    iTemp = cbLen;
  }

  // note:  iTemp won't exceed 'cbLen'

  if(iTemp > 0)
  {
    memcpy(&(pBuf->buffer[pBuf->nHead]), pData, iTemp);
    pBuf->nHead += iTemp; // update head pointer
  }

  if(pBuf->nHead >= pBuf->cbBuf) // this means I wrote to "the end"
  {
    cbLen -= iTemp; // maybe more left to write

    if(cbLen) // more to copy
    {
      pData += iTemp;

      memcpy(pBuf->buffer, pData, cbLen);
    }

    pBuf->nHead = cbLen; // regardless, do this
  }
  else
  {
    // won't get here unless I completed writing the data, *AND* the pointer's not at the end
  }

//  fprintf(stderr, "TEMP2 exit %d  %d %d %d\n", iTemp, pBuf->nHead, pBuf->nTail, cbLen);  // TEMPORARY
}

int my_buf_read(MY_BUF *pBuf, char *pData, int cbLen)
{
int iTemp, iRval;

//  fprintf(stderr, "TEMP enter %d %d %d\n", cbLen, pBuf->nHead, pBuf->nTail);  // TEMPORARY

  iTemp = pBuf->nHead - pBuf->nTail; // I write to 'head', read from 'tail'

  if(cbLen <= 0 || !iTemp) // nothing to read
  {
    return 0; // nothing to read
  }
  else if(iTemp > 0) // head preceeds tail in circular buffer
  {
    if(iTemp > cbLen)
    {
      iTemp = cbLen;
    }

    memcpy(pData, &(pBuf->buffer[pBuf->nTail]), iTemp);

    pBuf->nTail += iTemp; // move the 'tail' pointer
    pData += iTemp;
    cbLen -= iTemp;

    if(!cbLen || pBuf->nTail == pBuf->nHead) // I am done
    {
//      fprintf(stderr, "TEMP exit1 %d  %d %d %d\n", iTemp, pBuf->nHead, pBuf->nTail, cbLen);  // TEMPORARY

      return iTemp; // byte count
    }

    iRval = iTemp;  // what I've sent so far
  }
  else
  {
    iRval = 0; // nothing sent so far
  }

  // at this point, iHead < iTail which means it wraps around

  iTemp = pBuf->nTail + cbLen; // how much before the end of the buffer?
  if(iTemp > pBuf->cbBuf)
  {
    iTemp = pBuf->cbBuf - pBuf->nTail; // # of bytes to the end
  }
  else
  {
    iTemp = cbLen;
  }

  // note:  iTemp won't exceed 'cbLen'

  memcpy(pData, &(pBuf->buffer[pBuf->nTail]), iTemp);
  pBuf->nTail += iTemp; // update tail pointer

  iRval += iTemp;

  if(pBuf->nTail >= pBuf->cbBuf) // this means I read to "the end", so wrap around
  {
    cbLen -= iTemp; // anything left to read?

    if(cbLen) // more to read (could cheat and recurse)
    {
      pData += iTemp;

      iTemp = pBuf->nHead; // - pBuf->nTail; it will be zero right now
      if(iTemp > cbLen)
      {
        iTemp = cbLen; // only read "that much"
      }
      if(iTemp > 0)
      {
        memcpy(pData, pBuf->buffer, iTemp);

        iRval += iTemp;
      }

      pBuf->nTail = iTemp;  // up to but not including 'nHead'
    }
    else
    {
      pBuf->nTail = 0; // wrap around
    }
  }

//  fprintf(stderr, "TEMP exit2 %d  %d %d %d\n", iTemp, pBuf->nHead, pBuf->nTail, cbLen);  // TEMPORARY
  return iRval; // total # of bytes read
}

volatile int bDying = 0; // set to 1 to stop threads
volatile pthread_t xThread = 0; // the thread

#ifdef USE_CUSE

void * cuse_thread(void *pArg)
{
  signal(SIGHUP, SIG_DFL); // allow 'HUP' to interrupt me

  while(!bDying && !cuse_wait_and_process())
  {
    usleep(100);
  }

  fputs("TEMPORARY - thread dying\n", stderr);
  fflush(stderr);

  usleep(20000); // give things a chance to catch up (simple synchronization, TODO fix it later)

  xThread = 0;  // I'm dying anyway

  return NULL;
}
#endif // USE_CUSE

void hup_handler(int iSig) // call 'signal(SIGHUP, hup_handler)' to enable it
{
  bDying = 1;

  fprintf(stderr, "\nSOFT Terminating on signal %d\n", iSig);

//  signal(SIGHUP, SIG_DFL);  let this one stay, so I can HUP the thread
  signal(SIGKILL, SIG_DFL);
  signal(SIGTERM, SIG_DFL);
  signal(SIGINT, SIG_DFL);

  if(xThread == pthread_self())
  {
    pthread_cancel(xThread);
  }
}


int ProcessHasExited(int pid)
{
int iTemp, iTemp2;

  iTemp2 =  waitpid(pid, &iTemp, WNOHANG);

  if(iTemp2 < 0 || // assume it does not exist
     (iTemp2 > 0 && WIFEXITED(iTemp))) // process has exited?
  {
    return 1;
  }

  return 0; // it's still running
}


int do_main(int iListen, const char *szSoundFont)
{
#ifdef USE_CUSE
int iCuseUnit, iDev, iDev2;
struct cuse_dev *pDev = NULL;
#elif defined(USE_LIBFLUIDSYNTH)
fluid_settings_t * settings = NULL;
fluid_synth_t * synth = NULL;
fluid_audio_driver_t * adriver = NULL;
#ifdef USE_LIBFLUIDSYNTH_PARSER
fluid_midi_router_t* router = NULL;
fluid_midi_parser_t * parser = NULL;
fluid_midi_event_t * event = NULL;
#endif // USE_LIBFLUIDSYNTH_PARSER
int fluid_res;
#else // !USE_CUSE, !USE_LIBFLUIDSYNTH
int iDev, iDev2;
#endif // USE_CUSE, USE_LIBFLUIDSYNTH

#ifndef USE_LIBFLUIDSYNTH
pid_t pidFluidSynth = -1;
#endif // !USE_LIBFLUIDSYNTH

int iTemp, iTemp2;
unsigned long dwStart;
MY_BUF *pBuf1, *pBuf2;
void *pTemp;
char szDevName[32];
char tbuf[256];
struct sockaddr_storage saFrom; // sufficiently large enough to handle IPv4 or IPv6
socklen_t nSA;



  signal(SIGHUP, hup_handler);
  signal(SIGKILL, hup_handler); // may not work
  signal(SIGTERM, hup_handler); // should work
  signal(SIGINT, hup_handler);  // might work

  pBuf1 = (MY_BUF *)malloc(MY_BUF_SIZE * 2 + 2 * sizeof(*pBuf1));
  if(!pBuf1)
  {
    fprintf(stderr, "Not enough memory - errno=%d\n", errno);
    return -1;
  }

  pBuf1->cbBuf = MY_BUF_SIZE;
  pBuf1->nHead = pBuf1->nTail = 0;

  pBuf2 = (MY_BUF *)((unsigned char *)pBuf1 + MY_BUF_SIZE + sizeof(*pBuf1));
  pBuf2->cbBuf = MY_BUF_SIZE;
  pBuf2->nHead = pBuf2->nTail = 0;


#ifdef USE_CUSE
  iTemp = cuse_init(); // fails if you're not root

  if(iTemp)
  {
    fprintf(stderr, "cuse_init() returns %d - are you running as 'root'?\n", iTemp);
    return -1;
  }

  iCuseUnit = 0;
  iTemp = cuse_alloc_unit_number(&iCuseUnit);

  if(iTemp)
  {
    fprintf(stderr, "cuse_alloc_unit_number() returns %d\n", iTemp);
    iCuseUnit = -1; // an error flag
    goto error_exit;
  }

  pDev = cuse_dev_create(&sCM, (void *)pBuf1, (void *)pBuf2, 0, 0, 0666, "ethermidi%d", iCuseUnit);
  snprintf(szDevName, sizeof(szDevName)-1, "/dev/ethermidi%d", iCuseUnit);

  if(!pDev)
  {
    fprintf(stderr, "cuse_dev_create() returns NULL, errno=%d\n", errno);
    goto error_exit;
  }

  fputs("Creating thread\n", stderr);
  fflush(stderr);

  xThread = MyCreateThread(cuse_thread, NULL);

  if(!xThread)
  {
    fprintf(stderr, "Unable to create thread - errno=%d\n", errno);
    goto error_exit;
  }
#elif defined(USE_LIBFLUIDSYNTH)

  settings = new_fluid_settings();

  if(!settings)
  {
    fprintf(stderr, "Unable to create fluidsynth settings - errno=%d\n", errno);
    goto error_exit;
  }

#else // !USE_CUSE, !USE_LIBFLUIDSYNTH
  // create a FIFO to do this with

  bDying = 0; // initially must be zero

  snprintf(szDevName, sizeof(szDevName), "/tmp/EtherMIDI.%08x.fifo", (uint32_t)getpid());

  if(mkfifo(szDevName, 0664) < 0)
  {
    fprintf(stderr, "mkfifi() returns error, errno=%d\n", errno);
    goto error_exit;
  }

#endif // USE_CUSE



#ifdef USE_CUSE
  usleep(5000);    // to help synchronize

  fprintf(stderr, "Opening device \"%s\"\n", szDevName);
  fflush(stderr);

  iDev = open(szDevName, O_WRONLY); // the thing I'm writing to

  if(iDev == -1)
  {
    fprintf(stderr, "ERROR:  errno=%d opening %s\n", errno, szDevName);
    bDying = 1; // to shut things down

    pthread_kill(xThread, SIGHUP); // so I can kill it
    usleep(50000);    // to help synchronize
    pthread_kill(xThread, SIGHUP); // so I can kill it
    usleep(50000);    // to help synchronize

    goto error_exit;
  }
#elif !defined(USE_LIBFLUIDSYNTH)

  fprintf(stderr, "Opening FIFO \"%s\"\n", szDevName);
  fflush(stderr);

  iDev2= open(szDevName, O_RDONLY | O_NONBLOCK);
  if(iDev2 == -1)
  {
    fprintf(stderr, "ERROR:  errno=%d opening %s\n", errno, szDevName);
    iDev = -1; // not open yet
    goto error_exit;
  }

  iDev = open(szDevName, O_WRONLY | O_NONBLOCK);

  if(iDev == -1)
  {
    fprintf(stderr, "ERROR:  errno=%d opening %s\n", errno, szDevName);
    unlink(szDevName);   // clean up, too
    goto error_exit;
  }

  iTemp = 1;
  if(ioctl(iDev, FIONBIO, &iTemp) < 0)
  {
    fprintf(stderr, "Unable to set non-blocking I/O, errno=%d\n", errno);
  }
  else
  {
    fprintf(stderr, "Assigned non-blocking I/O\n");
  }
  iTemp = 1;
  if(ioctl(iDev, FIOASYNC, &iTemp) < 0)
  {
    fprintf(stderr, "Unable to set async I/O, errno=%d\n", errno);
  }
  else
  {
    fprintf(stderr, "Assigned async I/O\n");
  }

  bDying = 0;

  fflush(stderr);

#endif // USE_CUSE

  fputs("Starting fluidsynth\n", stderr);
  fflush(stderr);

#ifdef USE_LIBFLUIDSYNTH

  fluid_settings_setnum(settings, "synth.gain", 0.5);

  synth = new_fluid_synth(settings);
  if(!synth)
  {
    fprintf(stderr, "Unable to create fluidsynth - errno=%d\n", errno);
    goto error_exit;
  }

  if(*szSoundFont)
  {
    fluid_res = fluid_synth_sfload(synth, szSoundFont, 1); // TODO:  check result
  }
  else
  {
    fputs("WARNING:  no sound font file specified\n", stderr);
  }

  if(!szOutDev[0])  // use default output device
  {
#ifdef __FreeBSD__
    strcpy(szOutDev, DEFAULT_FREEBSD_OUT_DEVICE);
#else // linux
    strcpy(szOutDev, DEFAULT_LINUX_OUT_DEVICE);
#endif // __FreeBSD__ or linux
  }

  fluid_settings_setstr(settings, "audio.driver", szOutDev);

  adriver = new_fluid_audio_driver(settings, synth);

  if(!adriver)
  {
    fprintf(stderr, "Unable to create fluidsynth audio driver - errno=%d\n", errno);
    goto error_exit;
  }

#ifdef USE_LIBFLUIDSYNTH_PARSER
  router = new_fluid_midi_router(settings, fluid_synth_handle_midi_event, synth); // routes midi events to synth
  if(!router)
  {
    fprintf(stderr, "Unable to create fluidsynth midi router - errno=%d\n", errno);
    goto error_exit;
  }

  parser = new_fluid_midi_parser();
  if(!parser)
  {
    fprintf(stderr, "Unable to create fluidsynth parser - errno=%d\n", errno);
    goto error_exit;
  }
#endif // USE_LIBFLUIDSYNTH_PARSER

#else // !USE_LIBFLUIDSYNTH

  // now we need to run 'fluidsynth' with the appropriate parameters
  // TODO:  make sure I can find it in the path first and get the fullpath for it

  strcpy(tbuf, "midi.oss.device=");
  strcat(tbuf, szDevName);

  pidFluidSynth = WBRunAsync("/usr/local/bin/fluidsynth", "--no-shell", "-a", DEFAULT_FREEBSD_OUT_DEVICE, "-g", "0.5",
                             "-v",
#ifdef __FreeBSD__
                             "-m", DEFAULT_FREEBSD_OUT_DEVICE,
#else // assume Linux                             
                             "-m", DEFAULT_LINUX_OUT_DEVICE,
#endif // __FreeBSD__ vs Linux
                             "-o", tbuf, szSoundFont, NULL);

  close(iTemp);
#endif // USE_LIBFLUIDSYNTH


#ifndef USE_LIBFLUIDSYNTH
  if(pidFluidSynth != -1)
  {
#ifdef USE_CUSE
    fprintf(stderr, "Opening FIFO \"%s\"\n", szDevName);
    fflush(stderr);

    close(iDev);

    for(iTemp=0; iTemp < 10; iTemp++)
    {
      iDev = open(szDevName, O_WRONLY | O_NONBLOCK);

      if(iDev != -1 || errno != ENXIO)
      {
        break;
      }

      fprintf(stderr, "TEMPORARY:  retry=%d\n", iTemp);

      if(ProcessHasExited(pidFluidSynth))                               // so test if process exits also.
      {
        pidFluidSynth = -1;
        fprintf(stderr, "ERROR:  Fluidsynth has exited with code %d\n", iTemp);

        break;
      }

      usleep(100000); // wait 0.1 second
    }

    if(iDev == -1)
    {
      fprintf(stderr, "ERROR:  errno=%d opening %s\n", errno, szDevName);
      unlink(szDevName);   // clean up, too
      goto error_exit;
    }
    else
    {
      // send a MIDI reset command (this should preclude meta events by sending it twice)
      write(iDev, "\xff\xff", 2);

      fprintf(stderr, "\"%s\" open!  handle %d\n", szDevName, iDev);
      iTemp = 1;
      if(ioctl(iDev, FIONBIO, &iTemp) < 0)
      {
        fprintf(stderr, "Unable to set non-blocking I/O, errno=%d\n", errno);
      }
      iTemp = 1;
      if(ioctl(iDev, FIOASYNC, &iTemp) < 0)
      {
        fprintf(stderr, "Unable to set async I/O, errno=%d\n", errno);
      }

    }

    bDying = 0;
#endif // USE_CUSE

    // send a MIDI reset command (this should preclude meta events by sending it twice)
    for(iTemp=0; iTemp < 50; iTemp++)
    {
      usleep(100000); // wait 0.1 seconds

      if(ProcessHasExited(pidFluidSynth))
      {
        pidFluidSynth = -1;
        fprintf(stderr, "ERROR:  Fluidsynth has exited with code %d\n", iTemp);

        goto error_exit;
      }
    }

    write(iDev, "\xff\xff", 2);

    close(iDev2);
    iDev2 = -1;
#endif // USE_LIBFLUIDSYNTH

    fputs("Looping on input\n", stderr);
    fflush(stderr);

#ifdef USE_LIBFLUIDSYNTH
    fluid_synth_system_reset(synth); // reset
#endif // USE_LIBFLUIDSYNTH

    while(!bDying) // run forever
    {
      struct pollfd sFD[2];

      sFD[0].fd = iListen;
      sFD[0].events = POLLIN;
      sFD[0].revents = 0;
#ifdef USE_LIBFLUIDSYNTH
      iTemp = poll(&(sFD[0]), 1, 1);
#else // !
      sFD[1].fd = iDev;
      sFD[1].events = POLLOUT;
      sFD[1].revents = 0;
      iTemp = poll(&(sFD[0]), 2, 1);
#endif // USE_LIBFLUIDSYNTH

      if(iTemp < 0)
      {
        if(errno != EINTR)  // a serious problem
        {
          fprintf(stderr, "Ending on a serious note - errno=%d\n", errno);
          fflush(stderr);
        }

        break;
      }
      else if(iTemp > 0 && sFD[0].revents & POLLIN)
      {
        nSA = sizeof(saFrom);
        iTemp = recvfrom(iListen, tbuf, sizeof(tbuf), MSG_DONTWAIT, (struct sockaddr *)&saFrom, &nSA);

        // TODO:  make sure that the fluidsynth application is still running

        if(iTemp > 0)
        {
          // message format is as follows:
          // low endian long integer:  00000000H  byte sequence 00,00,00,00  [unknown purpose, always 0]
          // low endian long integer:  00000003H  byte sequence 03,00,00,00  [length of MIDI data?]
          // 3 bytes of data (MIDI sequence)
          struct __eth_midi__
          {
            uint32_t dwZero;
            uint32_t dwBytes;
            unsigned char aData[1];
          } *pData;

          pData = (struct __eth_midi__ *)tbuf;
          if(pData->dwBytes + sizeof(uint32_t) + sizeof(uint32_t) > iTemp)
          {
            // ignore data [it's bad]
            fprintf(stderr, "Ignoring bad data, dwBytes=%d, iTemp=%d\n", pData->dwBytes, iTemp);
          }
#ifdef USE_LIBFLUIDSYNTH
          else if(!bDying)
          {
#ifdef USE_LIBFLUIDSYNTH_PARSER
            for(iTemp2=0; iTemp2 < pData->dwBytes; iTemp2++)
            {
              event = fluid_midi_parser_parse(parser, pData->aData[iTemp2]);
              if(event)
              {
                fluid_midi_router_handle_midi_event(router, event);
              }
            }
#else // USE_LIBFLUIDSYNTH_PARSER
            do_midi_command(pData->dwBytes, pData->aData, synth);
#endif // USE_LIBFLUIDSYNTH_PARSER
          }
#else // !USE_LIBFLUIDSYNTH
          else if(!bDying)// && (sFD[1].revents & POLLOUT)) // it's ok to write the data
          {
            if((iTemp = write(iDev, pData->aData, pData->dwBytes)) != pData->dwBytes)
            {
              fprintf(stderr, "Write error, returns %d errno=%d\n", iTemp, errno);
            }
          }
#endif // USE_LIBFLUIDSYNTH
          else
          {
            fprintf(stderr, "MIDI packet dropped!\n");
          }
        }

//        fflush(stderr);
      }
      else
      {
        usleep(100);
      }

#ifndef USE_LIBFLUIDSYNTH
      if(ProcessHasExited(pidFluidSynth))
      {
        pidFluidSynth = -1;
        fprintf(stderr, "ERROR:  Fluidsynth has exited with code %d\n", iTemp);
        break;
      }
    }
#endif // USE_LIBFLUIDSYNTH

  }

  // NOW, end 'FluidSynth' task

error_exit:

#ifdef USE_LIBFLUIDSYNTH

#ifdef USE_LIBFLUIDSYNTH_PARSER
  if(parser)
  {
    delete_fluid_midi_parser(parser);
  }
  if(router)
  {
    delete_fluid_midi_router(router);
  }
#endif // USE_LIBFLUIDSYNTH_PARSER
  if(adriver)
  {
    delete_fluid_audio_driver(adriver);
  }
  if(synth)
  {
    delete_fluid_synth(synth);
  }

#else // !USE_LIBFLUIDSYNTH

  if(pidFluidSynth != -1)
  {
    fprintf(stderr, "Interrupted... killing fluidsynth\n");
    fflush(stderr);

    do
    {

      kill(pidFluidSynth, SIGHUP); // end it

      fprintf(stderr, "HUP sent to %d\n", pidFluidSynth);
      fflush(stderr);

      usleep(100000);

    } while(!ProcessHasExited(pidFluidSynth));

    fprintf(stderr, "Complete!  exit code %d\n", iTemp);
    fflush(stderr);
  }

#endif // USE_LIBFLUIDSYNTH

  bDying = 1; // make sure


#ifdef USE_CUSE
  fprintf(stderr, "destroying device, bDying=%d, xThread=%lxH\n", bDying, (unsigned long)xThread);
  fflush(stderr);

  bDying = 1; // make sure

  if(pDev)
  {
    cuse_dev_destroy(pDev);  // buh, bye!
  }

  usleep(100000); // give things a chance to die on their own

  if(xThread) // still there?
  {
    fputs("TEMPORARY - SIGHUP the thread\n", stderr);
    fflush(stderr);

    pthread_kill(xThread, SIGHUP);

    usleep(100000); // give things a chance to die on their own
  }

  if(xThread)
  {
    pthread_cancel(xThread); // force it
  }

  usleep(10000); // give things a chance to die on their own

  if(xThread)
  {
    pthread_join(xThread, &pTemp); // consider pthread_timedjoin_np and THEN cancel it
  }

  if(iCuseUnit != -1)
  {
    cuse_free_unit_number(iCuseUnit);
  }

// don't close the file handle - later I need to see what's up with this too
//    fputs("Closing handle\n", stderr);
//    fflush(stderr);
//
//    if(iDev != -1)
//    {
//      close(iDev); // should clean up and not hang
//    }

  cuse_uninit(); // ignore return, for now

#elif defined(USE_LIBFLUIDSYNTH)

  if(settings)
  {
    delete_fluid_settings(settings);
    settings = NULL; // by convention
  }

#else // !USE_CUSE, !USE_LIBFLUIDSYNTH

  if(iDev != -1)
  {
    fprintf(stderr, "Closing FIFO\n");
    fflush(stderr);

    close(iDev);  // _DO_ close it

    fprintf(stderr, "Removing FIFO\n");
    fflush(stderr);

    unlink(szDevName);   // clean up, too
  }

#endif // USE_CUSE

  fputs("Exiting\n", stderr);
  fflush(stderr);

  return 0;
}





unsigned int MyGetTickCount()
{
  struct timeval tv;
  gettimeofday(&tv, NULL); // 2nd parameter is obsolete anyway

  // NOTE:  this won't roll over the way 'GetTickCount' does in WIN32 so I'll truncate it
  //        down to a 32-bit value to make it happen.  Everything that uses 'MyGetTickCount'
  //        must handle this rollover properly using 'int' and not 'long' (or cast afterwards)
  return((unsigned int)((unsigned long)tv.tv_sec * 1000L + (unsigned long)tv.tv_usec / 1000L));
}

void MySleep(unsigned int dwMsec)
{
unsigned int dwEnd = MyGetTickCount() + dwMsec;

  signal(SIGHUP, SIG_DFL); // don't handle this signal any more

  while((int)(dwEnd - MyGetTickCount()) > 0)
  {
    usleep(100);
  }
}

// returns != 0 if MyGetTickCount exceeds specified time interval from 'dwStart'
int TimeIntervalExceeds(unsigned int dwStart, unsigned int dwMSec)
{
  return (int)(MyGetTickCount() - (dwStart + dwMSec)) >= 0;
}


#ifdef USE_CUSE

// CUSE device callbacks

int my_cm_open(struct cuse_dev *pCD, int fflags)
{
  return 0;
//  return -1;
}

int my_cm_close(struct cuse_dev *pCD, int fflags)
{
  return 0;
//  return -1;
}

int my_cm_read(struct cuse_dev *pCD, int fflags, void *user_ptr, int len)
{
char *pTemp;
int iTemp;
MY_BUF *pBuf1 = (MY_BUF *)cuse_dev_get_priv0(pCD);


  pTemp = malloc(len + 1);
  if(!pTemp)
  {
    return CUSE_ERR_NO_MEMORY;
  }

  iTemp = my_buf_read(pBuf1, pTemp, len);

  if(iTemp > 0)
  {
    cuse_copy_out(pTemp, user_ptr, iTemp);   // use cuse_copy_out to put data into 'user_ptr'
  }

  free(pTemp);

  return iTemp;
}

int my_cm_write(struct cuse_dev *pCD, int fflags, const void *user_ptr, int len)
{
char *pTemp;
int iRval;
MY_BUF *pBuf1 = (MY_BUF *)cuse_dev_get_priv0(pCD);


  if(len <= 0)
  {
    return 0;
  }

  pTemp = malloc(len + 1);
  if(!pTemp)
  {
    return CUSE_ERR_NO_MEMORY;
  }

  cuse_copy_in(user_ptr, pTemp, len); // use cuse_copy_in to get data from 'user_ptr'

  iRval = my_buf_remaining(pBuf1);
  if(iRval > len)
  {
    iRval = len; // how much to write (less than len if no room)
  }

  if(iRval > 0)
  {
    my_buf_write(pBuf1, pTemp, iRval); // assume it works
  }

  free(pTemp);

  return iRval;
}

int my_cm_ioctl(struct cuse_dev *pCD, int fflags, unsigned long cmd, void *user_data)
{
int iRval;
MY_BUF *pBuf1 = (MY_BUF *)cuse_dev_get_priv0(pCD);


  if(cmd == FIONREAD)
  {
    iRval = my_buf_len(pBuf1);
    cuse_copy_out(&iRval, user_data, sizeof(iRval));

    return 0;
  }
  else if(cmd == FIONBIO) // blocking on/off
  {
    cuse_copy_in(user_data, &iRval, sizeof(iRval));

    if(iRval)
    {
      // set to non-blocking
    }
    else
    {
      // set to blocking
    }

    return 0;
  }
  else if(cmd == SNDCTL_DSP_NONBLOCK) // snd devices assign non-block
  {
    // set to non-blocking


    return 0;
  }

  return -1;
}

int my_cm_poll(struct cuse_dev *pCD, int fflags, int events)
{
int iRval;
MY_BUF *pBuf1 = (MY_BUF *)cuse_dev_get_priv0(pCD);


  // 'events' will consist of bits 'CUSE_POLL_READ' 'CUSE_POLL_WRITE' and 'CUSE_POLL_ERROR'
  // if I can do any of these, return the appropriate bits.

  iRval = 0;

  if(events & CUSE_POLL_READ)
  {
    if(my_buf_len(pBuf1))  // check for read and assign bit to 'iRval'
    {
      iRval |= CUSE_POLL_READ;
    }
  }

  if(events & CUSE_POLL_WRITE)
  {
    if(my_buf_remaining(pBuf1)) // check for 'can write' and assign bit to 'iRval'
    {
      iRval |= CUSE_POLL_WRITE;
    }
  }

  if(events & CUSE_POLL_ERROR)
  {
    // check for error and assign bit to 'iRval'
  }


  return iRval;
}

#endif // USE_CUSE




// these borrowed from X11workbench, 'platform_helper.c'


WB_PROCESS_ID WBRunAsyncPipeV(WB_FILE_HANDLE hStdIn, WB_FILE_HANDLE hStdOut, WB_FILE_HANDLE hStdErr,
                              const char *szAppName, va_list va)
{
const char *pArg, *pPath;
char *pCur, *p1;
//const char *pAppName = NULL;
char **argv;
int i1, nItems, cbItems;
va_list va2;
WB_PROCESS_ID hRval;
WB_FILE_HANDLE hIn, hOut, hErr;


  hIn = hOut = hErr = WB_INVALID_FILE_HANDLE; // by convention (WIN32 needs this anyway)

  // FIRST, locate 'szAppName'

  if(hStdIn == WB_INVALID_FILE_HANDLE) // re-dir to/from /dev/null
  {
#ifndef WIN32
    hIn = open("/dev/null", O_RDONLY, 0);
#else // WIN32
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR *)malloc(SECURITY_DESCRIPTOR_MIN_LENGTH);

    if(pSD)
    {
      InitializeSecurityDescriptor(pSD,SECURITY_DESCRIPTOR_REVISION);
      pSD->bInheritHandle = TRUE; // what a pain

      hIn = CreateFile("NUL", GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       pSD, OPEN_EXISTING, NULL, NULL);
      free(pSD);
    }
#endif // WIN32
  }
  else
  {
#ifndef WIN32
    hIn = dup(hStdIn);
#else // WIN32
    if(!DuplicateHandle(GetCurrentProcess(), hStdIn,
                        GetCurrentProcess(), &hIn, GENERIC_READ,
                        TRUE, 0))
    {
      hIn = WB_INVALID_FILE_HANDLE;
    }
#endif // WIN32
  }

  if(hStdOut == WB_INVALID_FILE_HANDLE) // re-dir to/from /dev/null
  {
#ifndef WIN32
    hOut = open("/dev/null", O_WRONLY, 0);
#else // WIN32
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR *)malloc(SECURITY_DESCRIPTOR_MIN_LENGTH);

    if(pSD)
    {
      InitializeSecurityDescriptor(pSD,SECURITY_DESCRIPTOR_REVISION);
      pSD->bInheritHandle = TRUE; // what a pain

      hOut = CreateFile("NUL", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        pSD, OPEN_EXISTING, NULL, NULL);

      // ALTERNATE:  use 'SetHandleInformation(hOut, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT)'

      free(pSD);
    }
#endif // WIN32
  }
  else
  {
#ifndef WIN32
    hOut = dup(hStdOut);
#else // WIN32
    if(!DuplicateHandle(GetCurrentProcess(), hStdOut,
                        GetCurrentProcess(), &hOut, GENERIC_WRITE,
                        TRUE, 0))
    {
      hOut = WB_INVALID_FILE_HANDLE;
    }
#endif // WIN32
  }

  if(hStdErr == WB_INVALID_FILE_HANDLE) // re-dir to/from /dev/null
  {
#ifndef WIN32
    hErr = open("/dev/null", O_WRONLY, 0);
#else // WIN32
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR *)malloc(SECURITY_DESCRIPTOR_MIN_LENGTH);

    if(pSD)
    {
      InitializeSecurityDescriptor(pSD,SECURITY_DESCRIPTOR_REVISION);
      pSD->bInheritHandle = TRUE; // what a pain

      hErr = CreateFile("NUL", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        pSD, OPEN_EXISTING, NULL, NULL);
      free(pSD);
    }
#endif // WIN32
  }
  else
  {
#ifndef WIN32
    hErr = dup(hStdErr);
#else // WIN32
    if(!DuplicateHandle(GetCurrentProcess(), hStdErr,
                        GetCurrentProcess(), &hErr, GENERIC_WRITE,
                        TRUE, 0))
    {
      hErr = WB_INVALID_FILE_HANDLE;
    }
#endif // WIN32
  }

  // if file handle duplication fails, exit now with an error

  if(hIn == WB_INVALID_FILE_HANDLE ||
     hOut == WB_INVALID_FILE_HANDLE ||
     hErr == WB_INVALID_FILE_HANDLE)
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s hIn=%d hOut=%d hErr=%d\n", __FUNCTION__, hIn, hOut, hErr);

    if(hIn != WB_INVALID_FILE_HANDLE)
    {
      close(hIn);
    }
    if(hOut != WB_INVALID_FILE_HANDLE)
    {
      close(hOut);
    }
    if(hErr != WB_INVALID_FILE_HANDLE)
    {
      close(hErr);
    }

    return WB_INVALID_FILE_HANDLE;
  }

  // count arguments, determine memory requirement

  nItems = 0;
  cbItems = 2 * sizeof(char *) + strlen(szAppName) + 1;
  va_copy(va2, va);

  while(1)
  {
    pArg = va_arg(va2, const char *);
    if(!pArg)
    {
      break;
    }

    cbItems += strlen(pArg) + 1 + sizeof(char *);
    nItems++;
  }

  argv = (char **)malloc(64 + cbItems);
  if(!argv)
  {
    close(hIn);
    close(hOut);
    close(hErr);

    return WB_INVALID_FILE_HANDLE;
  }

  pCur = (char *)(argv + nItems + 2); // enough room for argument pointers

  p1 = strrchr(szAppName, '/');
  if(p1)
  {
    strcpy(pCur, p1 + 1); // just the name
  }
  else
  {
    strcpy(pCur, szAppName);
  }

  argv[0] = pCur;
  pCur += strlen(pCur) + 1;

  for(i1=1; i1 <= nItems; i1++)
  {
    pArg = va_arg(va, const char *);

    strcpy(pCur, pArg);
    argv[i1] = pCur;
    pCur += strlen(pCur) + 1;
  }

  argv[nItems + 1] = NULL;


  // now that I have a valid 'argv' I can spawn the process.
  // I will return the PID so that the caller can wait on it

  hRval = vfork();

  if(!hRval) // the 'forked' process
  {
    // vfork jumps here FIRST and temporarily suspends the calling thread
    // it also does NOT make a copy of memory so I must treat it as 'read only'

    if(dup2(hIn, 0) != -1 && dup2(hOut, 1) != -1 && dup2(hErr, 2) != -1) // stdin, stdout, stderr
    {
      extern char **environ; // this is what the man page says to do (it's part of libc)

      // TODO:  customize environment?

      signal(SIGHUP, SIG_IGN); // ignore 'HUP' signal before 'setsid' call ['daemon()' does this]
      setsid(); // so that I am my own process group (NOTE doing this might make it impossible to get the exit status... must verify everywhere)
      signal(SIGHUP, SIG_DFL); // restore default handling of 'HUP' ['daemon()' does this]

      execve(szAppName/*pAppName*/, argv, environ); // NOTE:  execute clears all existing signal handlers back to 'default' but retains 'ignored' signals
    }
    else
    {
      static const char szMsg[]="ERROR: 'dup2()' failure\n";
      write(2, szMsg, sizeof(szMsg) - 1); // stderr is still 'the old one' at this point
    }

    _exit(-1); // should never get here, but this must be done if execve fails
  }


  // once I've forked, I don't have to worry about copied memory or shared memory
  // and it's safe to free the allocated 'argv' array.

  free(argv);
  close(hIn);
  close(hOut);
  close(hErr);

  return hRval;
}


WB_PROCESS_ID WBRunAsync(const char *szAppName, ...)
{
WB_PROCESS_ID idRval;
va_list va;

  va_start(va, szAppName);

  idRval = WBRunAsyncPipeV(0, 1, 2, szAppName, va);
//  idRval = WBRunAsyncPipeV(WB_INVALID_FILE_HANDLE, WB_INVALID_FILE_HANDLE,
//                           WB_INVALID_FILE_HANDLE, szAppName, va);

  va_end(va);

  if(idRval == WB_INVALID_FILE_HANDLE)
  {
    /*WB_ERROR_PRINT*/fprintf(stderr, "Unable to run '%s'\n", szAppName);
  }
//  else
//  {
//    WB_ERROR_PRINT("Running '%s' - pid=%d\n", szAppName, idRval);
//  }

  return idRval;
}

WB_PROCESS_ID WBRunAsyncPipe(WB_FILE_HANDLE hStdIn, WB_FILE_HANDLE hStdOut, WB_FILE_HANDLE hStdErr,
                             const char *szAppName, ...)
{
WB_PROCESS_ID idRval;
va_list va;

  va_start(va, szAppName);

  idRval = WBRunAsyncPipeV(hStdIn, hStdOut, hStdErr, szAppName, va);

  va_end(va);

  return idRval;
}


#if defined(USE_LIBFLUIDSYNTH) && !defined(USE_LIBFLUIDSYNTH_PARSER)

// definitions from SFTSynth project and MIDI 1.0 spec from midi.org
// high nybble is channel except F0-FF
#define MIDI_NOTE_OFF      0x80
#define MIDI_NOTE_ON       0x90
#define MIDI_KEYPRESSURE   0xa0 /* poly key pressure */
#define MIDI_CONTROLLERS   0xb0
#define MIDI_PATCH_SELECT  0xc0 /* also 'program change' */
#define MIDI_CHAN_PRESSURE 0xd0 /* channel pressure */
#define MIDI_NOTE_BEND     0xe0
#define MIDI_SYSEX         0xf0 /* begin sysex */
#define MIDI_TIME_CODE     0xf1 /* quarter frame time code */
#define MIDI_SONG_POSITION 0xf2 /* song position pointer */
#define MIDI_SONG_SELECT   0xf3
#define MIDI_F4            0xf4 /* undefined in MIDI 1.0 spec */
#define MIDI_F5            0xf5 /* undefined in MIDI 1.0 spec */
#define MIDI_TUNE_REQUEST  0xf6
#define MIDI_EOX           0xf7 /* end of sysex */
#define MIDI_TICK          0xf8 /* timing clock aka timer tick */
#define MIDI_F9            0xf9 /* undefined in MIDI 1.0 spec */
#define MIDI_START         0xfa
#define MIDI_CONTINUE      0xfb
#define MIDI_STOP          0xfc
#define MIDI_FD            0xfd /* undefined in MIDI 1.0 spec */
#define MIDI_NOTESOFF      0xfe /* aka 'active sensing' - everything off if no message within 300msec */
#define MIDI_RESET         0xff /* reset all devices on the bus */

// This next function accepts a buffer that begins with a 'status' byte, i.e. a byte with
// the high bit set, as defined by the MIDI 1.0 spec.  Multiple byte sequences can
// be included for note on/off using "running status".
// Caveats:
//   a) 'running status' is ok for note on/off, i.e. [note on] N,V N,V N,V N,V N,V  (etc.)
//   b) for everything else, running status is ignored, next 'status' byte will
//      mark the beginning of a new MIDI command
//   c) for sysex, the ending 'F7' byte will be included.  F8 through FF will
//      cancel any sysex, so a sysex can only be sent if it ends with an F7.
//
// To parse a midi stream, you need to check for sysex and status >= 0xf8, and basically
// pack everything that starts with a status byte through the next status byte into a
// buffer, passing the buffer address and length [including status bytes] to this function.

// RESERVED:  allow multiple MIDI commands to be sent

void do_midi_command(unsigned int nBytes, unsigned char *pData, fluid_synth_t *pS)
{
int nCmd;
int nChan;

  // pData[0] must have high bit set for the first 'status' byte

  if(!nBytes || !pData)
  {
    return;
  }

  if(!(pData[0] & 0x80))
  {
    // TODO:  write something that checks 'nBytes'
//    fprintf(stderr, "Unable to parse MIDI command - %02x %02x %02x\n", pData[0], pData[1], pData[2]);
    return;
  }

//  while(nBytes > 0)
//  {
    if(pData[0] < 0xf0)
    {
      nChan = pData[0] & 0xf;
      nCmd = pData[0] & 0xf0;
    }
    else
    {
      nChan = -1;
      nCmd = pData[0]; // SYSEX etc.
    }

    pData ++; // point to the data now
    nBytes --;

    if(nCmd == MIDI_NOTE_OFF)
    {
      while(nBytes >= 2)
      {
        fluid_synth_noteoff(pS, nChan, pData[0]); // pData[1] is unused

        pData += 2; // skip to next byte if using 'running status'; no effect if there's only 1
        nBytes -= 2;

        if(pData[0] & 0x80)
        {
          break; // it's a new 'status'
        }
      }
    }
    else if(nCmd == MIDI_NOTE_ON)
    {
      while(nBytes >= 2)
      {
        if(pData[1] == 0) // note on of zero velocity is the same as note off
        {
          fluid_synth_noteoff(pS, nChan, pData[0]); // pData[1] is unused
        }
        else
        {
          // note, velocity as pData[0], pData[1]
          fluid_synth_noteon(pS, nChan, pData[0], pData[1]);
        }

        pData += 2; // skip to next byte if using 'running status'; no effect if there's only 1
        nBytes -= 2;

        if(pData[0] & 0x80)
        {
          break; // it's a new 'status'
        }
      }
    }
    else if(nCmd == MIDI_KEYPRESSURE)
    {
      // not handled - just ignore it
    }
    else if(nCmd == MIDI_CONTROLLERS)
    {
      if(nBytes >= 2)
      {
        fluid_synth_cc(pS, nChan, pData[0], pData[1]);
      }
    }
    else if(nCmd == MIDI_PATCH_SELECT)
    {
      if(nBytes >= 1)
      {
        fluid_synth_program_change(pS, nChan, pData[0]);
      }
    }
    else if(nCmd == MIDI_CHAN_PRESSURE)
    {
      if(nBytes >= 1)
      {
        fluid_synth_channel_pressure(pS, nChan, pData[0]);
      }
    }
    else if(nCmd == MIDI_NOTE_BEND)
    {
      if(nBytes >= 2)
      {
        unsigned short wBend = pData[1] & 0x7f; // low-endian dual 7-bit value, 0-16383

        wBend <<= 7;
        wBend |= (pData[0] & 0x7f);

        fluid_synth_pitch_bend(pS, nChan, wBend);
      }
    }
    else if(nCmd == MIDI_EOX) // end of sysex
    {
      // ignore (for now)
    }
    else if(nCmd == MIDI_SYSEX)
    {
      // TODO:  go into 'sysex' mode until I get MIDI_EOX

      unsigned char *pData2 = pData;
      unsigned short nBytes2 = nBytes;

      while(nBytes > 0 && *pData != MIDI_EOX)
      {
        if(*pData >= MIDI_TICK)
        {
          break; // bust out
        }

        pData++;
        nBytes--;
      }

      if(nBytes > 0 && *pData == MIDI_EOX) // it's ok we can do the sysex now
      {
        fluid_synth_sysex (pS, (const char *)pData2, nBytes2 - nBytes, NULL, NULL, NULL, 0);

        pData++; // skip the MIDI_EOX for the next part
        nBytes--;
      }
    }
    else if(nCmd == MIDI_RESET) // reset everything on the bus
    {
      fluid_synth_system_reset(pS);
    }

//    while(nBytes > 0 && !(pData[0] & 0x80));
//    {
//      pData++;
//      nBytes--;
//    }
//  }
}

#endif // defined(USE_LIBFLUIDSYNTH) && !defined(USE_LIBFLUIDSYNTH_PARSER)


